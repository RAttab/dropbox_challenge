#include <iostream>  

#include <set>
#include <list>
#include <vector>
#include <algorithm>

#include <cstdlib>
#include <cstdio>



struct t_box {
  t_box () : width(0), height(0), x(0), y(0) {}
  t_box (int w, int h) : width(w), height(h), x(0), y(0) {}
  int width;
  int height;
  int x, y;
  int area () const {return width*height;}
  int top () const {return y + height;}
  int right () const {return x + width;}
  void print () const {
    std::cerr << "Box(" << width << ", " << height << ") -> " << x << ", " << y << std::endl;
  }
};


typedef std::list<t_box> t_box_list;
typedef t_box_list::iterator t_box_it;
typedef t_box_list::const_iterator t_box_cit;


bool read_boxes (t_box_list& out_list);
t_box pack_boxes (t_box_list& box_list);
void print_boxes (const t_box_list& box_list, const t_box& bin);

int min (int a, int b) {return a < b ? a : b;}
int max (int a, int b) {return a > b ? a : b;}


/*!
Properly orders the blocks before running the solution on our dataset.
  It also prints out the results.
 */
void run_packer (t_box_list& list) {

  for (t_box_it it = list.begin(); it != list.end(); ++it) {
    if (it->height < it->width) {
      std::swap(it->height, it->width);
    }
  }

  t_box bin = pack_boxes (list);
  print_boxes(list, bin);
  std::cout << bin.area() << std::endl;
}


/*!
We want our blocks at be at least 3 big so that we can properly see them
  in the pretty pictures.
 */
void run_tests () {

  {
    t_box_list list;
    list.push_back(t_box(16,16));
    list.push_back(t_box(8,8));
    list.push_back(t_box(4,8));
    list.push_back(t_box(4,4));
    list.push_back(t_box(4,4));
    run_packer(list);
  }

  {
    t_box_list list;
    list.push_back(t_box(16,16));
    list.push_back(t_box(4,12));
    list.push_back(t_box(8,8));
    list.push_back(t_box(4,8));
    list.push_back(t_box(4,4));
    run_packer(list);
  }

  {
    t_box_list list;
    list.push_back(t_box(4,10));
    list.push_back(t_box(4,6));
    list.push_back(t_box(4,6));
    list.push_back(t_box(4,6));
    run_packer(list);
  }
 
  {
    srand(0);
    t_box_list list;
    for (int i = 0; i < 50; ++i) {
      int w = rand() % 47 + 3;
      int h = rand() % 47 + 3;
      list.push_back(t_box(w,h));
    }
    run_packer(list);
  }

  {
    srand(1);
    t_box_list list;
    for (int i = 0; i < 20; ++i) {
      int w = rand() % 97 + 3;
      int h = rand() % 97 + 3;
      list.push_back(t_box(w,h));
    }
    for (int i = 0; i < 80; ++i) {
      int w = rand() % 17 + 3;
      int h = rand() % 17 + 3;
      list.push_back(t_box(w,h));
    }

    run_packer(list);
  }


}


int main (int argc, char** argv) {

  if (argc > 1) {
    run_tests();
  }
  else {
    t_box_list box_list;
    if (!read_boxes(box_list)) {
      std::cerr << "Unable to read the box list!" << std::endl;
      exit(1);
    }
    run_packer(box_list);
  }
  return 0;
}




//! \brief Sorts by placing tallest boxes first.
struct t_box_ref_height_comp : 
  public std::binary_function<t_box_it, t_box_it, bool>
{
  bool operator() (const t_box_it& lhs, const t_box_it& rhs) const {
    if (lhs->height == rhs->height) 
      return lhs->area() > rhs->area();
    return lhs->height > rhs->height;
  }
} box_ref_height_comp;


typedef std::multiset<t_box_it, t_box_ref_height_comp> t_box_ref_list;
typedef t_box_ref_list::iterator t_box_ref_it;




//! \brief Orders by box position
struct t_box_pos_comp :
  public std::binary_function<t_box, t_box, bool>
{
  bool operator() (const t_box& lhs, const t_box& rhs) const {
    if (lhs.x != rhs.x)
      return lhs.x < rhs.x;
    
return lhs.y < rhs.y;
  }
} box_pos_comp;

// An std::set ensures we don't have duplicates.
typedef std::set<t_box, t_box_pos_comp> t_free_list;
typedef t_free_list::iterator t_free_it;




void process_first_box (t_box_ref_list& box_queue, t_box& bin);
void place_box_greedy (t_box& new_box, t_box& bin, t_free_list& free_list);
void place_box_free_list (t_box_ref_list& box_queue, t_free_list& free_list, const t_box& bin);
void extend_bin (t_box& bin, const t_box& new_box);


/*
All boxes in the provided list must satisfy this condition
    \code height >= width; \endcode
 */
t_box pack_boxes (t_box_list& box_list) {
  
  t_box_ref_list box_queue;
  for (t_box_it it = box_list.begin(); it != box_list.end(); ++it) {
    box_queue.insert(it);
  }

  t_box bin;
  t_free_list free_list;

  process_first_box(box_queue, bin);

  while (box_queue.size() > 0) {
    t_box_it first_box = *(box_queue.begin());
    place_box_greedy(*first_box, bin, free_list);
    box_queue.erase(box_queue.begin());
    
    place_box_free_list(box_queue, free_list, bin);
  }

  return bin;
}



//! The first box defines the height of the bin.
void process_first_box (t_box_ref_list& box_queue, t_box& bin) {
  t_box_ref_it first_ref = box_queue.begin();
  t_box_it first_box = *first_ref;

  extend_bin(bin, *first_box);
  first_box->x = first_box->y = 0;

  std::cerr << "1 ";
  first_box->print();

  box_queue.erase(first_ref);
}

void place_box_greedy (t_box& new_box, t_box& bin, t_free_list& free_list) {
  new_box.x = bin.width;
  new_box.y = 0;
  extend_bin (bin, new_box);

  std::cerr << "G ";
  new_box.print();

  t_box free_box;
  free_box.x = new_box.x;
  free_box.y = new_box.y + new_box.height;
  free_box.height = bin.height - new_box.height;
  free_list.insert(free_box);
}


std::pair<t_free_it, t_box_ref_it> 
free_list_search (t_box_ref_list& box_queue, t_free_list& free_list, const t_box& bin);
void free_list_update (t_free_it free_it, const t_box_it& queue_box, t_free_list& free_list, const t_box& bin);
void set_free_height (t_free_it free_it, t_free_list& free_list, int height);
void set_free_y (t_free_it free_it, t_free_list& free_list, int new_y);
bool is_free_redundant (t_free_list& free_list, const t_box& new_free);


void place_box_free_list (t_box_ref_list& box_queue, t_free_list& free_list, const t_box& bin) {

  while (true) {
    std::cerr << std::endl << "F LIST (" << free_list.size() << ")" << std::endl;
    for (t_free_it it = free_list.begin(); it != free_list.end(); it++) {
      std::cerr << "\t";
      it->print(); 
    }
    std::cerr << std::endl;



    std::pair<t_free_it, t_box_ref_it> result = free_list_search(box_queue, free_list, bin);
    
    const t_free_it free_it = result.first;
    const t_box_ref_it queue_it = result.second;
    if (free_it == free_list.end())
      return;

    // Place the new box along the the top (rotate as needed).
    const t_box& old_free = *free_it;
    const t_box_it& queue_box = *queue_it;

    if (queue_box->height > old_free.height) {
      std::swap(queue_box->height, queue_box->width);
    }

    queue_box->x = old_free.x;
    queue_box->y = (old_free.y + old_free.height) - queue_box->height;
    box_queue.erase(queue_it);

    std::cerr << "F ";
    queue_box->print();
    std::cerr << "\tF";  
    old_free.print();

    free_list_update(free_it, queue_box, free_list, bin);
  }
}


/*!
Find the biggest box we can shove in a free spot (if any).
  This is the slowest spot of our algorithm. Lots of stuff to check.
*/
std::pair<t_free_it, t_box_ref_it> 
free_list_search (t_box_ref_list& box_queue, t_free_list& free_list, const t_box& bin) 
{
  int max_area = -1;
  t_free_it found_free = free_list.end();
  t_box_ref_it found_box = box_queue.end();
  

  for (t_free_it free_it = free_list.begin(); free_it != free_list.end(); ++free_it) {
    int free_width = bin.width - free_it->x;

    for (t_box_ref_it queue_it = box_queue.begin(); queue_it != box_queue.end(); ++queue_it) {
      const t_box_it& queue_box = *queue_it;
      
      // Is it worth continuing?
      if (queue_box->area() <= max_area) 
	continue;
      
      // Can we fit it in?
      if (queue_box->height > max(free_width, free_it->height))
	continue;
      if (queue_box->width > min(free_width, free_it->height))
	continue;

      // "Yes we can!" -Obama
      max_area = queue_box->area();
      found_free = free_it;
      found_box = queue_it;
    }
  }

  return std::make_pair(found_free, found_box);
}

/*!
Updates the free list to take into account the added block.
 */
void free_list_update (t_free_it free_it, const t_box_it& queue_box, t_free_list& free_list, const t_box& bin) {
  t_free_it old_free = free_it;
  int new_free_x = queue_box->right();
 
  int old_y = old_free->y;
  int old_height = old_free->height;
 
  // Update the entries.
  //  Trim the free blocks so that they don't overlap our new block.
  for (t_free_it it = free_list.begin(); it != free_list.end(); ++it) {
    
    // If the free block apears after then it can't overlap anything.
    if (it->x >= new_free_x)
      break;

    int height_diff = it->top() - queue_box->y;
    int y_diff = queue_box->top() - it->y;

    // A block is overlapping the bottom of the free block so trim the bottom.
    if (y_diff > 0 && queue_box->top() < it->top()) {
      set_free_y(it, free_list, it->y + y_diff);
    }
    // A block is overlapping the top of a the free block so trim the top.
    else if (height_diff > 0 && queue_box->y >= it->y) {
      set_free_height(it, free_list, it->height - height_diff);
    }
    // The block is overlapping the entire free block, get rid of it.
    else if (y_diff > 0 && height_diff > 0) {
      set_free_height(it, free_list, 0);
    }
  }

  // Create the new free box on the right.
  if (new_free_x < bin.width) {
    t_box new_free;
    new_free.x = new_free_x;
    new_free.y = old_y;
    new_free.height = old_height;
    if (!is_free_redundant(free_list, new_free)) {
      free_list.insert(new_free);
    }
  }
}

bool is_free_redundant (t_free_list& free_list, const t_box& new_free) {
  for (t_free_it it = free_list.begin(); it != free_list.end(); ++it) {
    if (it->x <= new_free.x && it->y <= new_free.y) {
      if (it->y + it->height >= new_free.y + new_free.height) {
	return true;
      }
    }
  }
  return false;
}


void extend_bin (t_box& bin, const t_box& new_box) {
  bin.width = max(bin.width, new_box.x + new_box.width);
  bin.height = max(bin.height, new_box.y + new_box.height);
}

void set_free_height (t_free_it free_it, t_free_list& free_list, int height) {
  free_list.erase(free_it);
  if (height <= 0) 
    return;

  t_box free_copy = *free_it;
  free_copy.height = height;
  free_list.insert(free_copy);
}

void set_free_y (t_free_it free_it, t_free_list& free_list, int new_y) {
  free_list.erase(free_it);
  int new_height = free_it->height - (new_y - free_it->y);
  if (new_height <= 0) 
    return;

  t_box free_copy = *free_it;
  free_copy.height = new_height;
  free_copy.y = new_y;
  free_list.insert(free_copy);
}


/*!
\todo Fill this in later.
 */
bool read_boxes (t_box_list& out_list) {

  int box_count = 0;
  std::cin >> box_count;

  for (int i = 0; i < box_count; ++i) {
    t_box new_box;

    scanf("%d %d", &new_box.width, &new_box.height);

    out_list.push_back(new_box);
  }
  return true;
}


typedef std::vector< std::vector<char> > t_2d_array;

bool print_side (t_2d_array& print_bin, int x, int y, char c);

void print_boxes (const t_box_list& box_list, const t_box& bin) {
  
  std::cerr << std::endl << "Bin(" << bin.width << ", " << bin.height << ")" << std::endl;

  t_2d_array print_scr;
  print_scr.resize(bin.width);
  for (int i = 0; i < bin.width; ++i) {
    print_scr[i].resize(bin.height);
    for (int j = 0; j < bin.height; ++j)
      print_scr[i][j] = ' ';
  }

  for (t_box_cit box_it = box_list.begin(); box_it != box_list.end(); ++box_it) {
    const t_box& box = *box_it; 
    box.print();

    for (int i = 0; i < box.height; ++i) {
      char c = i == 0 || i == box.height-1 ? '+' : '-';
      if (!print_side(print_scr, box.x, box.y+i, c)) {
	std::cerr << "ERR: ";
	box.print();
      }
      
      if (box.width == 1) continue;

      if (!print_side(print_scr, box.x + box.width-1, box.y + i, c)) {
	std::cerr << "ERR: ";
	box.print();
      }
    }

    for (int i = 1; i < box.width-1; ++i) {
      if (!print_side(print_scr, box.x+i, box.y, '|')) {
	std::cerr << "ERR: ";
	box.print();
      }
      
      if (box.height == 1) continue;

      if (!print_side(print_scr, box.x+i, box.y + box.height-1, '|')) {
	std::cerr << "ERR: ";
	box.print();
      }
    }
  }

  for (int i = 0; i < bin.width; ++i) {
    for (int j = 0; j < bin.height; ++j) {
      std::cerr << print_scr[i][j];
    }
    std::cerr << std::endl;
  }

}

bool print_side (t_2d_array& print_bin, int x, int y, char c) {
  bool err = print_bin[x][y] != ' ';
  print_bin[x][y] = err ? '*' : c; 
  return !err;
}


